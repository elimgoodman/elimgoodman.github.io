---
layout: page
title: Hi
tagline: Supporting tagline
---
{% include JB/setup %}

<!-- Headlines -->
<h1>Build Ambitious Programs with Speed, Ease, and Safety<h1>
<h1>An Environment That Fits Your Hand</h1>
<h1>The Hackable IDE from the Future</h1>
<h1>The Editor for the Other 90% of Your Job.</h1>
<h1>More powerful abstractions. More safety. Less yelling.</h1>
<h1>Efficiency, safety, and customizability, without all the cursing.</h1>
<h1>Built to model. Built to explore. Built to debug. Built by you.</h1>

<!-- Subheadings -->
<p>
	Mesh is a programming environment that combines the best aspects of modern IDEs, the user-hackability of traditional text editors, the safety of functional programming languages, and the more progressive features of domain specific language workbenches into a cogent and elegant package. It's like Smalltalk, Emacs, and Haskell had a baby.
</p>
<p>
	Most of what we do while programming isn't writing code - we explore unfamiliar codebases, refactor existing functionality, model the domain of the program, and debug broken features. Mesh is a programming environment designed to make these activities faster and safer.
</p>

<!-- Features -->
<h3>An editor that understands your code</h3>

The Mesh language and the Mesh editor are one in the same. This allows the editor to grok your code on a deep level, offering advanced autocomplete and code introspection out of the box. This also gives you a huge amount of power and flexibility to customize your editor (detailed below). And don't worry - the code is all stored as text on disk, and can be run from the command line.

<h3>A safe, expressive language</h3>

The Mesh language is succinct, expressive, and modern. It features functions as first-class objects, a straightforward type system, a novel system for restricting access to global state and external IO, and out-of-the-box support for concurrency. It draws inspiration from Go, Erlang, Haskell, and Lisp, but differs from each in important ways.

<h3>Your program is an object</h3>
In Mesh, the program that you're building is actually just a regular old object. You can interact with it using the environment's REPL, allowing you to run arbitrary Mesh commands on it to gather information or perform alterations. This is incredibly powerful - instead of having to worry about all of the dangers inherent with making sweeping changes to vanilla text, you can leverage the Mesh language's type- and state-safety to alter your program with confidence. And unlike refactoring tools in existing IDEs, Mesh allows you to easily roll your own from scratch and bind them to hotkeys. You can build up a vocabulary of safe, powerful alterations that allow you to generate code quickly and refactor boldly.

<h3>The editor is an object</h3>
Just as the program being built is a regular Mesh object that's available to the REPL, so too is the editing environment. This allows you to build ambitious extensions to the editor without having to learn another language like Vimscript or Emacs Lisp. What's even better is that you can make on-the-fly changes to the editor right from the REPL. And because you use the Mesh language for all modifications to the editor, you get that delicious type- and state-safety for free. When your environment is so easily modifiable, you'll be surprised how much you tailor it to fit your hand.

<h3>The VM is an object</h3>

So, the program you're building is a Mesh object, and the editor is a Mesh object. And believe it or not, the Mesh VM <em>itself</em> is a Mesh object. To put it another way, you can programatically instantiate VM objects (either from the editor's REPL, or within your program itself) and then run arbitrary code on them. This allows you do some amazing things: create custom live-coding and debugging environments; serialize the contents of a production VM and then reload it on your development machine to diagnose a problem; mock out a VM's connections to the outside world to create an ideal test environment. Additionally, Mesh's VMs have robust mechanisms for talking to each other, which allows you to easily create concurrent and distributed programs.

<h3>Organize your code, visually</h3>
While Mesh is <em>not</em> a "visual programming language", it does utilize a GUI to make it easier to navigate and view your program. Mesh makes it easy to lay out and traverse your code in a way that's right for you. Set up views that programatically query your program to display specific regions; view tests alongside the code they utilize; organize your code visually in the same way you might lay out papers on your desk. And don't worry - you'll never need to touch your mouse while using Mesh. Most editors restrict you to one file per tab - in Mesh, you decide what gets shown where.

<h3>Model your domain</h3>
Most large programs are comprised of two major parts: a declarative model of the concepts involved in the problem domain, and imperative code that turns that model into something that the user can interact with. Mesh makes it easy to create type-safe, declarative domain models, so that these two parts of your program can be cleanly separated. Additionally, Because of Mesh's UI paradigm described above, you can also create concept-specific UIs for the domain models in your system, which means there's no syntax for you to remember. Why write it in text when you can just fill out a form?

<h3>Add safety as you go</h3>
As programs grow in complexity, there are more and more things that might go wrong. Tests are good for enforcing the functionality of imperative code, but are not so good at enforcing the structural integrity of the declarative portions of your program. Type checkers are good for this, but they're limited (and trying to cram all of the correctness you need into the type system can be very confusing). Mesh allows you to write and run arbitrary "checkers" to ensure the correctness of your program along any dimensions you see fit. Because the Mesh program is a regular object, traversing it to look for problems is a cinch. And Mesh allows you to attach and display arbitrary metadata on any part of your program, so you can easily see the results of your checkers.
