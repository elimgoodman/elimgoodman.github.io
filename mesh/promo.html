---
layout: page
title: Hi
tagline: Supporting tagline
---
{% include JB/setup %}

<!-- Headlines -->
<!-- <h1>Build Ambitious Programs with Speed, Ease, and Safety<h1>
<h1>An Environment That Fits Your Hand</h1>
 --><h1>Mesh: The Hackable IDE from the Future</h1>
<!-- <h1>The Editor for the Other 90% of Your Job.</h1>
<h1>More powerful abstractions. More safety. Less yelling.</h1>
 -->
<!--  <h1>Efficiency, safety, and customizability, without all the cursing.</h1>
 --><!-- <h1>Built to model. Built to explore. Built to debug. Built by you.</h1>
 -->
 <!-- <h1>Built for abstraction. Built for safety. Built for hackability.</h1> -->

<!-- Subheadings -->
<p>
	Mesh is a programming environment that combines the best aspects of modern IDEs, the user-hackability of traditional text editors, the safety of pure functional programming languages, and the more progressive features of domain specific language workbenches into a cogent and elegant package. It's like Smalltalk, Emacs, Haskell, and Jetbrains MPS had a baby.
</p>
<p class="feature-desc">
	Mesh is designed to allow you to do one thing first and foremost: <strong>offload as much as you can to the environment</strong>. As a programmer, your brainpower is a scarce resource. Mesh makes it easy for the computer to help you as much as possible, so you can use your brainpower for the things that matter.
</p>

<!-- Features -->
	<h3 class="feature" href="#understand">An editor that understands your code</h3>
<div class="feature-desc" id="understand">
	The Mesh language and the Mesh editor are one in the same. This allows the editor to grok your code on a deep level, offering advanced autocomplete and code introspection out of the box. This also gives you the ability to customize the editor is some unique and powerful ways (detailed below). And don't worry - the code is all stored as text on disk, and can be run from the command line.
</div>

<h3 class="feature">A safe, expressive language</h3>

<div class="feature-desc">
	The Mesh language is succinct, expressive, and modern. It features functions as first-class objects, a straightforward type system, a novel system for restricting access to global state and external IO, and out-of-the-box support for concurrency. It draws inspiration from Go, Erlang, Haskell, and Clojure, but differs from each in important ways.
</div>

<h3 class="feature">Built on the JVM</h3>
<div class="feature-desc">
	Even though Mesh has its own notion of VMs (detailed below), the entire system is built on the rock-solid foundation of the JVM. Mesh programs get the performance and stability afforded by the JVM, and can interoperate with JVM bytecode produced by Java and other JVM languages. This means that Mesh programs have access to a huge library of battle-tested JVM libraries right out of the box.
</div>

<h3 class="feature">Your program is an object</h3>
<div class="feature-desc">
	In Mesh, the program that you're building is actually just a regular old object. You can interact with it using the environment's REPL, allowing you to run arbitrary Mesh commands on it to gather information or perform alterations. This is incredibly powerful - instead of having to worry about all of the dangers inherent with making sweeping changes to regular text files, you can leverage the Mesh language's type- and state-safety to alter your program with confidence. And unlike refactoring tools in existing IDEs, Mesh allows you to easily roll your own from scratch and bind them to hotkeys. You can build up a vocabulary of safe, powerful alterations that allow you to generate code quickly and refactor boldly.
</div>

<h3 class="feature">The editor is an object</h3>
<div class="feature-desc">
	Just as the program being built is a regular Mesh object that's available to the REPL, so too is the editing environment. This allows you to build ambitious extensions to the editor without having to learn another language like Vimscript or Emacs Lisp. What's even better is that you can make on-the-fly changes to the editor right from the REPL. And because you use the Mesh language for all modifications to the editor, you get that delicious type- and state-safety for free. When your environment is so easily modifiable, you'll be surprised how much you tailor it to fit the problem at hand.
</div>

<h3 class="feature">The VM is an object</h3>
<div class="feature-desc">
	So, the program you're building is a Mesh object, and the editor is a Mesh object. And believe it or not, the Mesh VM <em>itself</em> is a Mesh object. To put it another way, you can programatically instantiate VM objects (either from the editor's REPL, or within your program itself) and then run arbitrary code on them. This allows you do some amazing things, like create custom live-coding and debugging environments; serialize the contents of a production VM and then reload it on your development machine to diagnose a problem; or mock out a VM's connections to the outside world to create an ideal test environment. Additionally, Mesh's VMs have robust mechanisms for talking to each other, which allows you to easily create concurrent and distributed programs.
</div>

<h3 class="feature">Organize your code, visually</h3>
<div class="feature-desc">
	While Mesh is <em>not</em> a "visual programming language", it does utilize a GUI to make it easier to navigate and view your program. Mesh's perspective system allows you to do things that are impossible in other editing environments: set up views that programatically query your program to display regions that match a specific criteria; pull up the tests for a function and view the two side by side with the tap of a key; or organize your code spacially in the same way you might lay out papers on your desk. And don't worry - you'll never need to touch your mouse while using Mesh.
</div>

<h3 class="feature">Model your domain</h3>
<div class="feature-desc">
	Most large programs are comprised of two major parts: a declarative model of the concepts involved in the problem domain, and imperative code that turns that model into something that the user can interact with. Mesh makes it easy to create type-safe, declarative domain models, so that these two parts of your program can be cleanly separated. Modeling your program using declarative concepts is a huge boon - declarative concepts have no notion of time or state, which makes them much easier to reason about and change with confidence. Additionally, Because of Mesh's UI paradigm described above, you can also create concept-specific UIs for the domain models in your system, which means there's no syntax for you to remember. Why write it in text when you can just fill out a form?
</div>

<h3 class="feature">Add safety as you go</h3>
<div class="feature-desc">
	As programs grow in complexity, there are more and more things that might go wrong. Tests are good for enforcing the functionality of imperative code, but are not so good at enforcing the structural integrity of the declarative portions of your program. Type checkers can be good for this, but they're limited (and trying to cram all of the correctness you need into the type system can be very confusing). Mesh allows you to write and run arbitrary "checkers" to ensure the correctness of your program along any dimensions you see fit. Because the Mesh program is a regular object, traversing it to look for problems is a cinch. And Mesh allows you to attach and display arbitrary metadata on any part of your program, so you can easily see the results of your checkers.
</div>

<style>
/*	.feature-desc {
		display: none;
	}

	h3.feature {
		cursor: pointer;
	}

*/

body {
	margin-top: 48px;
}

h3 {
	margin-bottom: 12px;
}

.feature-desc {
	margin-bottom: 36px;
}

h1 {
	font-size: 54px;
	margin-bottom: 24px;
}

</style>

<script type="text/javascript" src="/assets/themes/twitter/js/jquery.js"></script>
<script type="text/javascript">
	// $("h3.feature").click(function(e) {
	// 	var id = $(this).attr('href');
	// 	$(id).show();
	// 	e.preventDefault();
	// })
</script>
