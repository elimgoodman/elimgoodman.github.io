---
layout: page
title: Mesh
tagline: Supporting tagline
---
{% include JB/setup %}

<!-- Headlines -->
<!-- <h1>Build Ambitious Programs with Speed, Ease, and Safety<h1>
<h1>An Environment That Fits Your Hand</h1>
 --><h1>Mesh: The Hackable IDE from the Future</h1>
<!-- <h1>The Editor for the Other 90% of Your Job.</h1>
<h1>More powerful abstractions. More safety. Less yelling.</h1>
 -->
<!--  <h1>Efficiency, safety, and customizability, without all the cursing.</h1>
 --><!-- <h1>Built to model. Built to explore. Built to debug. Built by you.</h1>
 -->
 <!-- <h1>Built for abstraction. Built for safety. Built for hackability.</h1> -->

<!-- Subheadings -->

<h2>What's the situation?</h2>

<p>Programmers today enjoy, on the whole, a very high level of abstraction when they sit down to do work. What might have been a couple hundred lines of custom C code can now be done with a few lines of Node or Python. Additionally, frameworks like Ruby on Rails raise the level of abstraction higher still.</p>

<p>This is a good thing. This rise in the level of abstraction has allowed programmers to become incredibly efficient, with one or two developers able to do the work of four or five using older technologies. However, this rise in abstraction has a large downside: rises in the level of abstraction bring them with commensurate rises in the level of <strong>risk</strong>.</p>

<p>Current programming languages make it relatively easy for us to build abstractions specific to our own programs - we can model the shape of data using classes and structs, imperative functionality with functions, and higher-order abstractions with macros. However, as our program grows and abstractions accumulate atop one another, it becomes incredibly risky to change anything not at the highest level of abstraction. Because so many things come to rely on the lower levels, changes to these levels are often exceedingly hard to reason about and execute with confidence.</p>

<p>Some languages do include safety mechanisms to offset this risk. Type systems are the most common of these, but other more esoteric solutions exist. For example, Haskell includes special constructs that make writing impure code rather cumbersome, with the belief that pure code is easier to reason about, and thus easier to modify with confidence. Languages like Typed Clojure and Typescript also have safety mechanisms that programmers can add at their own discretion, which allows for incremental rises in safety as the program evolves.</p>

<p>However, unlike abstractions, there are no languages that allow the programmer to easily add domain-specific layers of safety to their programs. Without this ability, the level of safety for a given language remains static, while the level of abstraction is able to rise perilously high.</p>

<p>It might be tempting to think that automated testing is the solution here, but to reach for tests as the answer is to misunderstand the problem. Tests are good at demonstrating the correctness of imperative code. However, this brings us to the second facet of the abstraction/safety problem - in most modern languages, all concepts in the language have one method of representation: as imperative code. This is both dangerous. Imperative code is hard to deal with it because it has to contend with the two most gnarly aspects of programming - state and time. Changes to state over time are exceedingly hard to reason about.</p>

<p>There is another way to represent the concepts in programs, and that is <strong>declaratively</strong>. Declarative models don't have any ability to modify state or be influenced by time, and are thus much easier to reason about. So, instead of adding safety by encouraging programmers to write tests, Mesh enables programmers to represent their program using declarative structures whenever possible. It also enables programmers to add progressive levels of safety to these declarative representations - not tests, but something more akin to constraints in a relational database.</p>

<p>Using this strategy, we believe that Mesh can allow programmers to enjoy an extremely high level of abstraction using declarative concepts, while accumulating an increasing level of safety using constraints on those concepts.</p>

